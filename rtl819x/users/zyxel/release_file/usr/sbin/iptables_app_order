#!/bin/sh
. /sbin/functions.sh
include /sbin
lock /tmp/.order_filter.lock

proto=$(uci_get network wan proto)
if [ "$proto" == "pppoe" ] || [ "$proto" == "pptp" ];then
	WAN="ppp0"
else
	WAN=$(uci_get network wan ifname)
fi
LAN="br0"

dos_enable=$(uci_get firewall general dos_enable)
nat_enable=$(uci_get nat general nat)
upnp_enable=$(uci_get upnpd config enabled)
icmp_ping=$(uci_get firewall general pingEnabled)
#parental_enable=$(uci_get parental general enable)
firewall_enable=$(uci_get firewall general filterEnabled)
firewall_rule_count=$(uci_get firewall general rules_count)
sessions_user=$(uci_get nat general sessions_user)
igmpproxy_enable=$(uci_get igmpproxy general igmpEnabled)
spi_enable=$(uci_get firewall general spi_enable)


## reload parental control
#/usr/sbin/parental_iptable.sh boot

## reload icmp ping
iptables -D INPUT -p icmp -j input_icmp 2>/dev/null
iptables -D FORWARD -p icmp -j forwarding_icmp 2>/dev/null

### insert ping filter on FORWARD chain (firewall need to be prior to icmp ping filter)
iptables -I FORWARD -p icmp -j forwarding_icmp 2>/dev/null

## reload NAT related
iptables -D FORWARD -j forwarding_rule_nat 2>/dev/null
iptables -D FORWARD -j forwarding_rule_porttrigger 2>/dev/null
#### this rule is different from wsq50 
#iptables -D FORWARD -j forwarding_rule_dmz   

if [ "$nat_enable" == "enable" ]; then
	iptables -I FORWARD -j forwarding_rule_nat 2>/dev/null
	iptables -I FORWARD -j forwarding_rule_porttrigger 2>/dev/null
fi

## reload firewall chain (firewall need to be prior to icmp ping filter)
iptables -D INPUT -j input_rule 2>/dev/null
iptables -D OUTPUT -j output_igmp 2>/dev/null
iptables -D FORWARD -j forwarding_rule_filter 2>/dev/null

if [ "$firewall_enable" == "1" ]; then
	#iptables -A INPUT -j input_rule 2>/dev/null
	iptables -I FORWARD -j forwarding_rule_filter 2>/dev/null
	iptables -A OUTPUT -j output_igmp 2>/dev/null
fi

## reload parental control
/usr/sbin/parental_iptable.sh boot

## reload firewall_blockdevice chain
iptables -D INPUT -j blockdevice_input_rule 2>/dev/null
iptables -D FORWARD -j blockdevice_filter 2>/dev/null

if [ "$firewall_enable" == "1" ]; then
#       iptables -A INPUT -j blockdevice_input_rule
        iptables -I FORWARD -j blockdevice_filter
fi

##  insert xmpp-agent chain
iptables -N xmpp_server_list
iptables -D FORWARD -j xmpp_server_list 2>/dev/null
iptables -I FORWARD -j xmpp_server_list

## reload upnp 
iptables -D FORWARD -i $WAN ! -o $WAN -j MINIUPNPD 2>/dev/null
iptables -t nat -D PREROUTING -i $WAN -j MINIUPNPD
iptables -t nat -D POSTROUTING -o $WAN -j MINIUPNPD-POSTROUTING
iptables -t mangle -D PREROUTING -i $WAN -j MINIUPNPD
if [ "$upnp_enable" == "1" ]; then
	iptables -A FORWARD -i $WAN ! -o $WAN -j MINIUPNPD 2>/dev/null
	iptables -t nat -I PREROUTING -i $WAN -j MINIUPNPD
	iptables -t nat -I POSTROUTING -o $WAN -j MINIUPNPD-POSTROUTING
	iptables -t mangle -I PREROUTING -i $WAN -j MINIUPNPD
fi

# this is different from wsq50
## reload NAT (DMZ part)
#if [ "$nat_enable" == "enable" ]; then
#        iptables -A FORWARD -j forwarding_rule_dmz 2>/dev/null
#fi

# reload TCPMSS
iptables -t mangle -D FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
iptables -t mangle -I FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu

## For StreamBoost Integration NozKer API
iptables -D INPUT -i lo -j ACCEPT
iptables -A INPUT -i lo -j ACCEPT

#guest wireless LAN
/usr/sbin/firewall_guest_wlan


##check mode,only router mode have igmpproxy
#local sys_mode=$(get_sys_mode)
sys_mode=`flash get OP_MODE | awk -F'=' '{print $2}'`

[ "$sys_mode" == "0" ] && {
## reload multicast bypass rule
iptables -D FORWARD -p udp -i $WAN -d 224.0.0.0/240.0.0.0 -j ACCEPT 2>/dev/null
iptables -N input_igmp 2>/dev/null
iptables -F input_igmp 2>/dev/null
iptables -D INPUT -j input_igmp 2>/dev/null
if [ "$igmpproxy_enable" == "1" ]; then
	iptables -A FORWARD -p udp -i $WAN -d 224.0.0.0/240.0.0.0 -j ACCEPT
	iptables -A input_igmp -p igmp -i $WAN -d 224.0.0.1 -j ACCEPT
	iptables -A input_igmp -p igmp -i $WAN -d 224.0.0.2 -j ACCEPT
	iptables -A INPUT -j input_igmp 
fi
}

#reload vpn releated
[ -f "/sbin/netbios_daemon" ] && /sbin/netbios_daemon reload

## relaod nat session limit
iptables -D FORWARD -j forwarding_session_limit 2>/dev/null
if [ "$sessions_user" != "" ]; then
        iptables -A FORWARD -j forwarding_session_limit 2>/dev/null
fi

## VPN bypass rule
iptables -D INPUT -j input_vpn 2>/dev/null
iptables -D FORWARD -j forward_vpn 2>/dev/null
vpn_check=""
[ -f "/var/psk.txt" ] && vpn_check=$(cat /var/psk.txt)
if [ -n "$vpn_check" ]; then
	iptables -A INPUT -j input_vpn
	iptables -A FORWARD -j forward_vpn
fi

## reload DoS chain
#iptables -D INPUT -j DOS_INPUT 2>/dev/null
#iptables -D FORWARD -j DOS_FORWARD 2>/dev/null
#iptables -t mangle -D PREROUTING -j DOS_LAND_ATTACK_LOG 2>/dev/null

#if [ "$dos_enable" == "1" ]; then
#       iptables -A INPUT -j DOS_INPUT 2>/dev/null
#        iptables -A FORWARD -j DOS_FORWARD 2>/dev/null
#        iptables -t mangle -I PREROUTING -j DOS_LAND_ATTACK_LOG 2>/dev/null
#fi

## lan and local traffic must be accept by default, if there is exception rule, the default action will be ACCEPT
#iptables -D INPUT -j lan_local_default 2>/dev/null
#iptables -D FORWARD -i $LAN -j ACCEPT 2>/dev/null
#iptables -D INPUT -j ACCEPT 2>/dev/null
#iptables -D INPUT -j DROP 2>/dev/null
#iptables -D FORWARD -j ACCEPT 2>/dev/null
#iptables -D FORWARD -j DROP 2>/dev/null

##Protect lan_local_default
#iptables -N lan_local_default 2>/dev/null
#iptables -F lan_local_default
#iptables -A lan_local_default ! -i $WAN -j ACCEPT

#target=`uci get firewall.general.target`

##For WAN to LAN and always DROP
#iptables -A INPUT -j lan_local_default

#if [ "$target" == "DROP" ] ; then
#	iptables -A FORWARD -i $LAN -j ACCEPT
#fi

##set remote MGMT Rule
iptables -D INPUT -j RMMG_WWW_INPUT 2>/dev/null
iptables -A INPUT -j RMMG_WWW_INPUT 2>/dev/null
iptables -D INPUT -j RMMG_TELNET_INPUT 2>/dev/null
iptables -A INPUT -j RMMG_TELNET_INPUT 2>/dev/null

##set file sharing
[ -f "/sbin/firewall_FTP" ] && {
	/sbin/firewall_FTP
	iptables -D INPUT -j FTP_INPUT 2>/dev/null
	iptables -A INPUT -j FTP_INPUT 2>/dev/null
}

[ -f "/sbin/firewall_samba" ] && {
	/sbin/firewall_samba
	iptables -D INPUT -j SAMBA_INPUT 2>/dev/null
	iptables -A INPUT -j SAMBA_INPUT 2>/dev/null
}

## SSH
/usr/sbin/firewall_ssh start
iptables -D INPUT -j RMMG_SSH_INPUT 2>/dev/null
iptables -A INPUT -j RMMG_SSH_INPUT 2>/dev/null

##set remote TR069
iptables -N RMMG_TR069 2>/dev/null
iptables -D INPUT -j RMMG_TR069 2>/dev/null
iptables -A INPUT -j RMMG_TR069 2>/dev/null

##set for SNMP
iptables -D INPUT -j RMMG_SNMP 2>/dev/null
iptables -A INPUT -j RMMG_SNMP 2>/dev/null

if [ "$firewall_enable" == "1" ]; then
        iptables -A INPUT -j blockdevice_input_rule
        iptables -A INPUT -j input_rule
fi

### insert ping filter on INPUT chain (firewall need to be prior to icmp ping filter)
iptables -A INPUT -p icmp -j input_icmp

## set for Block traffic which NOT  from LAN's subnet
iptables -D INPUT -j BLOCK_DIFF_SUBNET 2>/dev/null
iptables -A INPUT -j BLOCK_DIFF_SUBNET 2>/dev/null

iptables -t filter -F SNMPchain 2>/dev/null
iptables -t filter -F SNMPchain2 2>/dev/null

if [ "$spi_enable" == "0" ]; then
	iptables -A INPUT -j ACCEPT 2>/dev/null
	iptables -A FORWARD -j ACCEPT 2>/dev/null
fi

## RIP
iptables -D INPUT -j rip_rule 2>/dev/null
iptables -A INPUT -j rip_rule 2>/dev/null

## For StreamBoost Integration NozKer API
#iptables -D INPUT -p tcp --dport 80 -i lo -j ACCEPT  2>/dev/null
#iptables -I INPUT -p tcp --dport 80 -i lo -j ACCEPT

## reload SPI
iptables -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables -D INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

############### WSQ50 have , but wsr30 no check  
## lan and local traffic must be accept by default, if there is exception rule, the default action will be ACCEPT
iptables -D INPUT -j lan_local_default
iptables -D FORWARD -i $LAN -j ACCEPT
iptables -D INPUT -j ACCEPT
iptables -D INPUT -j DROP
iptables -D FORWARD -j ACCEPT
iptables -D FORWARD -j DROP

##Protect lan_local_default
iptables -N lan_local_default
iptables -F lan_local_default
iptables -A lan_local_default -i $LAN -j ACCEPT
iptables -A lan_local_default -i guest-lan -j ACCEPT

target=`uci get firewall.general.target`

## reload DoS chain
iptables -D INPUT -j DOS_INPUT 2>/dev/null
iptables -D FORWARD -j DOS_FORWARD 2>/dev/null
iptables -t mangle -D PREROUTING -j DOS_LAND_ATTACK_LOG 2>/dev/null

if [ "$dos_enable" == "1" ]; then
        iptables -A INPUT -j DOS_INPUT 2>/dev/null
        iptables -A FORWARD -j DOS_FORWARD 2>/dev/null
        iptables -t mangle -I PREROUTING -j DOS_LAND_ATTACK_LOG 2>/dev/null
fi

##For WAN to LAN and always DROP
iptables -A INPUT -j lan_local_default

#Block traffic from main LAN to guest or visitor LAN
guestLan="guest-lan"
#visitorLan="br-visitor1"
#visitor_network_feature=$(wifisys_tool -g 1 -f 2)
#[ -z "$visitor_network_feature" ] && visitor_network_feature="0"

iptables -D FORWARD -i $LAN -o $guestLan -j DROP
#iptables -D FORWARD -i $LAN -o $visitorLan -j DROP

iptables -A FORWARD -i $LAN -o $guestLan -j DROP
#[ "$visitor_network_feature" == "2" ] && iptables -A FORWARD -i $LAN -o $visitorLan -j DROP

if [ "$target" == "DROP" ] ; then
        iptables -A FORWARD -i $LAN -j ACCEPT
fi
#########################################################
#guest wireless LAN
#/usr/sbin/firewall_guest_wlan

lock -u /tmp/.order_filter.lock
