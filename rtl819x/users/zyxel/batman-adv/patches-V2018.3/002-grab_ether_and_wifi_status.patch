--- net/batman-adv/bat_v_elp.c	2018-09-14 16:55:59.000000000 +0800
+++ net/batman-adv/bat_v_elp.c	2018-11-07 09:57:19.846881807 +0800
@@ -67,6 +67,58 @@
 			   msecs_to_jiffies(msecs));
 }
 
+#define	WSR30_RTL8192C_METRIC_INFO
+#define WSR30_RTL8192C_LINK_RATE
+#if	defined(WSR30_RTL8192C)
+int		calculate_metric(struct wifi_mesh_node *);
+extern struct hlist_head	mesh_head;
+extern int	batadv_get_wifi_link_rate(struct net_device *, u8 *);
+
+/* input: realdev - input iface
+ *        addr - neighbor addr
+ *        node - mesh info
+ * return the corresponding mesh node by ptr
+ * return -ENOENT(-2) if failed,
+ *        node ptr if successfully
+ */
+static int	fake_cfg80211_get_station
+(struct net_device *realdev, 
+ u8 *addr, 
+ struct wifi_mesh_node *node)
+{
+	int	retval, _retval, found=0;
+	struct wifi_mesh_node	*tmp;
+
+#if	defined(WSR30_RTL8192C_LINK_RATE)
+	/* grab link rate */
+	if(strcmp(realdev->name, "wlan0-msh0") == 0){
+		retval=batadv_get_wifi_link_rate(realdev, addr);
+		_retval=(retval*45)/100;
+	}else{
+		retval=batadv_get_wifi_link_rate(realdev, addr);
+		_retval=(retval*6)/10;
+		//printk(KERN_ERR "[B@TMAN] rate %d => %d \n", retval, _retval);
+	}
+#endif
+
+#if	defined(WSR30_RTL8192C_METRIC_INFO)
+
+#endif
+
+	/* for debug */
+	/*printk(KERN_ERR "[Metric-%d] %d - %d - %d %x %x\n", node->band, 
+		node->rssi_metric, node->cu_metric, node->noise_metric, node, node->metric);
+	printk(KERN_ERR "[Iface] %x %x %x %x %x %x\n", 
+		node->addr[0], node->addr[1], node->addr[2], 
+		node->addr[3], node->addr[4], node->addr[5]);
+	printk(KERN_ERR "[Neigh] %x %x %x %x %x %x\n", 
+		node->orig[0], node->orig[1], node->orig[2], 
+		node->orig[3], node->orig[4], node->orig[5]);*/
+RETN:
+	return	_retval;
+}
+#endif	//WSR30_RTL8192C
+
 /**
  * batadv_v_elp_get_throughput() - get the throughput towards a neighbour
  * @neigh: the neighbour for which the throughput has to be obtained
@@ -77,9 +124,14 @@
 static u32 batadv_v_elp_get_throughput(struct batadv_hardif_neigh_node *neigh)
 {
 	struct batadv_hard_iface *hard_iface = neigh->if_incoming;
+#if	defined(WSR30_RTL8192C)
+	struct port_status		link_settings;
+	struct wifi_mesh_node	*sinfo;
+#else
 	struct ethtool_link_ksettings link_settings;
-	struct net_device *real_netdev;
 	struct station_info sinfo;
+#endif
+	struct net_device *real_netdev;
 	u32 throughput;
 	int ret;
 
@@ -101,7 +153,25 @@
 		real_netdev = batadv_get_real_netdev(hard_iface->net_dev);
 		if (!real_netdev)
 			goto default_throughput;
+#if	defined(WSR30_RTL8192C)
+	#if	defined(WSR30_RTL8192C_LINK_RATE)
+		ret=fake_cfg80211_get_station(real_netdev, neigh->addr, sinfo);
+		dev_put(real_netdev);
 
+		if(ret == -ENOENT) {
+			/* Node is not associated anymore! It would be
+			 * possible to delete this neighbor. For now set
+			 * the throughput metric to 0.
+			 */
+			return	0;
+		} else if(ret > 0) {
+			ret=10*ret;   /* Mbps -> 100kbps */
+			return	ret;
+		} else {
+			return	0;
+		}
+	#endif	
+#else	//original method: cfg80211
 		ret = cfg80211_get_station(real_netdev, neigh->addr, &sinfo);
 
 		dev_put(real_netdev);
@@ -118,6 +188,7 @@
 			goto default_throughput;
 
 		return sinfo.expected_throughput / 100;
+#endif
 	}
 
 	/* if not a wifi interface, check if this device provides data via
@@ -125,7 +196,11 @@
 	 */
 	memset(&link_settings, 0, sizeof(link_settings));
 	rtnl_lock();
+#if	defined(WSR30_RTL8192C)
+	ret=batadv_get_port_status(hard_iface->net_dev, &link_settings);	//0: successfully
+#else
 	ret = __ethtool_get_link_ksettings(hard_iface->net_dev, &link_settings);
+#endif
 	rtnl_unlock();
 
 	/* Virtual interface drivers such as tun / tap interfaces, VLAN, etc
@@ -140,14 +215,23 @@
 	 * setting to differentiate between genuine link throughput information
 	 * and placeholders installed by virtual interfaces.
 	 */
+#if	defined(WSR30_RTL8192C)
+	if(!ret) {
+		/* link characteristics might change over time */
+		if (link_settings.duplex == 1)
+#else
 	if (ret == 0 && link_settings.base.autoneg == AUTONEG_ENABLE) {
 		/* link characteristics might change over time */
 		if (link_settings.base.duplex == DUPLEX_FULL)
+#endif
 			hard_iface->bat_v.flags |= BATADV_FULL_DUPLEX;
 		else
 			hard_iface->bat_v.flags &= ~BATADV_FULL_DUPLEX;
-
+#if	defined(WSR30_RTL8192C)
+		throughput=link_settings.speed;
+#else
 		throughput = link_settings.base.speed;
+#endif
 		if (throughput && throughput != SPEED_UNKNOWN)
 			return throughput * 10;
 	}
@@ -166,6 +250,177 @@
 	return BATADV_THROUGHPUT_DEFAULT_VALUE;
 }
 
+#if	defined(WSR30_RTL8192C)
+typedef int rtk_api_ret_t;
+typedef u32 rtk_port_t;
+typedef u32 rtk_data_t;
+typedef enum    rtk_port_duplex_e
+{
+    PORT_HALF_DUPLEX = 0,
+    PORT_FULL_DUPLEX,
+    PORT_DUPLEX_END
+} rtk_port_duplex_t;
+typedef enum    rtk_port_linkStatus_e
+{
+    PORT_LINKDOWN = 0,
+    PORT_LINKUP,
+    PORT_LINKSTATUS_END
+} rtk_port_linkStatus_t;
+extern rtk_api_ret_t rtk_port_phyStatus_get(rtk_port_t port, rtk_port_linkStatus_t *pLinkStatus, rtk_data_t *pSpeed, rtk_data_t *pDuples);
+enum    PORTID {
+    PHY0 = 0,
+    PHY1 = 1,
+    PHY2 = 2,
+    PHY3 = 3,
+    PHY4 = 4,
+    PHY5 = 5,
+    CPU =6,
+    MULTEXT = 10,
+};
+struct wifi_mib_value {
+    u32 rssi_threshold;
+    u32 cu_threshold;
+    u32 noise_threshold;
+    u32 rssi_weight;
+    u32 cu_weight;
+    u32 noise_weight;
+};
+struct wifi_mib_value  mib_value_of_5g =
+{
+    .rssi_threshold = 15,
+    .cu_threshold   = 160,
+    .noise_threshold    = 50,
+    .rssi_weight        = 2,
+    .cu_weight      = 3,
+    .noise_weight   = 2,
+};
+struct wifi_mib_value  mib_value_of_2g =
+{
+    .rssi_threshold = 5,
+    .cu_threshold   = 100,
+    .noise_threshold    = 30,
+    .rssi_weight        = 4,
+    .cu_weight      = 12,
+    .noise_weight   = 5,
+};
+
+#define EnForceMode         (1<<25)
+#define PollLinkStatus      (1<<24)
+#define big_endian32(x)     (x)
+#define big_endian(x)       big_endian32(x)
+#ifndef REG32
+    #define REG32(reg)          (*((volatile uint32 *)(reg)))
+#endif
+#ifndef READ_MEM32
+    #define READ_MEM32(reg)     big_endian(REG32(reg))
+#endif
+#define REAL_SWCORE_BASE    0xBB800000
+#define SWCORE_BASE     REAL_SWCORE_BASE
+#define PCRAM_BASE      (SWCORE_BASE+0x4100)
+#define PSRP0           (0x028 + PCRAM_BASE)    /* Port Configuration Register of Port 0 */
+#define PCRP0           (0x004 + PCRAM_BASE)    /* Port Status Register Port 0 */
+
+#define PortStatusLinkUp    (1<<4)              /* Link UP */
+#define PortStatusDuplex    (1<<3)              /* Duplex */
+#define PortStatusLinkSpeed_MASK    (3<<0)      /* Link Speed */
+#define PortStatusLinkSpeed_OFFSET  0
+#define PortStatusLinkSpeed10M      (0<<0)      /* 10M */
+#define PortStatusLinkSpeed100M     (1<<0)      /* 100M */
+#define PortStatusLinkSpeed1000M    (2<<0)      /* 1000M */
+#define PortStatusLinkSpeedReserved (3<<0)      /* Reserved Speed */
+
+
+#if	defined(WSR30_RTL8192C_METRIC_INFO)
+int		calculate_metric
+(struct wifi_mesh_node *node)
+{
+	u32 rssi_metric=node->rssi_metric;
+	u32 cu_metric=node->cu_metric;
+	u32 noise_metric=node->noise_metric;
+	int is_5g=(node->band == 5)? 1:0;
+	int is_2g=(node->band == 2)? 1:0;
+	u32 rssi_score, cu_score, noise_score, cur_metric;
+	struct wifi_mib_value	*tmp_mib_value;
+
+	if(is_5g)
+		tmp_mib_value=&mib_value_of_5g;
+	else if(is_2g)
+		tmp_mib_value=&mib_value_of_2g;
+
+	rssi_score=(rssi_metric < tmp_mib_value->rssi_threshold)? (100-rssi_metric)<<2 : (100-rssi_metric);
+	cu_score=(cu_metric > tmp_mib_value->cu_threshold)? (cu_metric<<1) : cu_metric;
+	noise_score=((cu_metric > tmp_mib_value->cu_threshold)&&(noise_metric > tmp_mib_value->noise_threshold))? noise_metric : 0;
+	cur_metric=(rssi_score*tmp_mib_value->rssi_weight) + (cu_score*tmp_mib_value->cu_weight) + (noise_score*tmp_mib_value->noise_weight);
+
+	node->ewma_metric=cur_metric;
+	//printk(KERN_INFO "[BATMAN] band-%d metric-%d\n", node->band, cur_metric);
+	return	cur_metric;
+}
+#endif	//WSR30_RTL8192C_METRIC_INFO
+
+/* for debug */
+int		get_port_status
+(struct net_device *netdev, 
+ struct port_status *status)
+{
+	int port=0;
+	int	retval=-1;
+	u32	regData, regData_PCR, data;
+
+	for(port=PHY0; port<CPU; port++) {
+		regData=READ_MEM32(PSRP0+((port)<<2));
+		regData_PCR=READ_MEM32(PCRP0+((port)<<2));
+		printk(KERN_INFO "[%d] ", port);
+		data=regData_PCR & EnForceMode;
+		if(data) {
+			data=regData_PCR & PollLinkStatus;
+			if(data)
+				printk(KERN_INFO "disable Auto-Negotiation\n");
+			else
+				printk(KERN_INFO "- Force Mode disable!!!\n");
+		} else {
+			printk(KERN_INFO "- Force Mode disable!!!\n");
+		}
+
+		regData=READ_MEM32(PSRP0+((port)<<2));
+		data=regData & PortStatusLinkUp;
+		/* link */
+		if(data) {
+			status->link=1;
+			retval=1;
+			printk(KERN_INFO "Link-up\n");
+		} else {
+			status->link=0;
+		}
+		/* full/half duplex */
+		data=regData & PortStatusDuplex;
+		if(data) {
+			status->duplex=1;
+			printk(KERN_INFO "Full duplex\n");
+		} else {
+			printk(KERN_INFO "Half duplex\n");
+			status->duplex=0;
+		}
+		/* link rate */
+		data=(regData & PortStatusLinkSpeed_MASK) >> PortStatusLinkSpeed_OFFSET;
+		if(data == PortStatusLinkSpeed100M) {
+			status->speed=100;
+			printk(KERN_INFO "100M\n");
+		} else if(data == PortStatusLinkSpeed1000M) {
+			status->speed=1000;
+			printk(KERN_INFO "1000M\n");
+		} else if(data == PortStatusLinkSpeed10M) {
+			status->speed=10;
+			printk(KERN_INFO "10M\n");
+		} else {
+			status->speed=500;
+			printk(KERN_ERR "500M\n");
+		}
+	}
+	return	retval;
+}
+#endif	//WSR30_RTL8192C
+
 /**
  * batadv_v_elp_throughput_metric_update() - worker updating the throughput
  *  metric of a single hop neighbour
--- net/batman-adv/bat_v_elp.h	2018-09-14 16:55:59.000000000 +0800
+++ net/batman-adv/bat_v_elp.h	2018-11-05 17:54:55.587186302 +0800
@@ -21,6 +21,34 @@
 
 #include "main.h"
 
+#ifndef WSR30_RTL8192C
+#define WSR30_RTL8192C
+#endif
+#if		defined(WSR30_RTL8192C)
+struct port_status {
+	int link;		//0/1
+	int duplex;		//0/1
+	int speed;		//10/100/1000/500
+};
+struct wifi_mesh_node {
+	struct hlist_node	list;
+	u8	dirty;
+	u8	band;
+	u8	orig[ETH_ALEN];
+	u8	addr[ETH_ALEN];
+	u32	rssi_metric;
+	u32	cu_metric;
+	u32	noise_metric;
+	u32	ewma_metric;
+	u32	throughput;
+	unsigned long	timeval;	//jiffies + 600*HZ
+	int	(*metric)(struct wifi_mesh_node *);
+	//int	(*transfer_tbl)(u8 band, int metric);
+};
+extern int	batadv_get_orig_info(struct net_device *, struct wifi_mesh_node *);
+extern int	batadv_get_port_status(struct net_device *, struct port_status *);
+#endif	////WSR30_RTL8192C
+
 struct sk_buff;
 struct work_struct;
 
--- net/batman-adv/hard-interface.c	2018-11-06 14:10:56.147032178 +0800
+++ net/batman-adv/hard-interface.c	2018-11-07 10:00:10.978881445 +0800
@@ -326,6 +326,16 @@
 	u32 wifi_flags = 0;
 	struct net_device *real_netdev;
 
+#if defined(WSR30_RTL8192C)
+	{
+		char	*tmp;
+		tmp=strstr(net_device->name, "msh0");
+		if(tmp)
+			wifi_flags |= BATADV_HARDIF_WIFI_CFG80211_DIRECT;
+		printk(KERN_ERR "[B@TMAN] dev(%s) => wifi_flags(%d)\n", net_device->name, wifi_flags);
+	}
+#endif
+
 	if (batadv_is_wext_netdev(net_device))
 		wifi_flags |= BATADV_HARDIF_WIFI_WEXT_DIRECT;
 
--- net/batman-adv/hard-interface.h	2018-09-14 16:55:59.000000000 +0800
+++ net/batman-adv/hard-interface.h	2018-11-06 13:56:55.687033953 +0800
@@ -28,6 +28,10 @@
 #include <linux/stddef.h>
 #include <linux/types.h>
 
+#ifndef	WSR30_RTL8192C
+#define	WSR30_RTL8192C
+#endif
+
 struct net_device;
 struct net;
 
