--- batman-adv-2018.3/net/batman-adv/fast_batman.c	2018-11-09 10:21:56.234513660 +0800
+++ batman-adv-2018.3/net/batman-adv/fast_batman.c	2018-11-09 13:42:22.482488255 +0800
@@ -70,7 +70,7 @@
 static void	fastbat_show_list_entry(u32 idx);
 static FAST_BAT	*fastbat_skb_peel_and_search(struct sk_buff *);
 static void fastbat_del_list_entry(FAST_BAT *);
-static struct	batadv_orig_node *fastbat_grab_orig_by_neigh(u8 *addr, struct net_device *); 
+static struct batadv_orig_node	*fastbat_grab_orig_by_neigh(u8 *addr, struct net_device *); 
 static void	fastbat_del_local_entry(FAST_LOCAL *);
 static void	fastbat_show_local_entry(void);
 
@@ -1411,6 +1411,7 @@
 					continue;
 				if(!memcmp(bat->orig, orig_node->orig, ETH_ALEN)) {
 					bat->dirty=1;   /*dirty*/
+					dirty=1;
 					FASTBAT_DBG_RAW_MSG("[F@STBAT] find out:(o)%pM\n (s)%pM\n (d)%pM\n (rs)%pM\n (rd)%pM\n", 
 						bat->orig, bat->src1, bat->dst1, bat->src, bat->dst);
 					//fastbat_del_list_entry(bat);
@@ -1477,35 +1478,65 @@
 void	fastbat_purge_dirty_entry
 (void *tmp)
 {
-	FAST_BAT	*bat, 
-				*bat_to_be_del;
+	FAST_BAT	*bat; //*bat_to_be_del;
 	FAST_LOCAL	*local, 
 				*local_to_be_del;
-	int			idx=0;
+	u32			idx=0;
 
 	FASTBAT_DBG_RAW_MSG("[F@STBAT] start to purge bats ...\n");
 	for(; idx<FAST_BAT_LIST_LEN; idx++) {
 		hlist_for_each_entry(bat, &bats[idx], list) {
 			if(bat->dirty) {
+				//fastbat_del_list_entry(bat);
 				FASTBAT_DBG_RAW_MSG("[F@STBAT] dirty bat! eliminates this bat!\n");
+#if	1
+				if(bat->list.next != NULL) {
+					queue_delayed_work(batadv_event_workqueue, &fastbat_work, msecs_to_jiffies(FASTBAT_DIRTY_PURGE));
+				}
+				mutex_lock(&bats_lock);
+				hlist_del(&bat->list);
+				mutex_unlock(&bats_lock);
+				kfree(bat);
+				break;
+#else	//weird, sometimes it would panic
 				if(bat->list.next == NULL) {
+					FASTBAT_DBG_RAW_MSG("[F@STBAT] null\n");
 					mutex_lock(&bats_lock);
-					bats[idx].first=NULL;
+					//bats[idx].first=NULL;
+					hlist_del(&bat->list);
 					mutex_unlock(&bats_lock);
 					kfree(bat);
 					break;
 				} else {
-					bat_to_be_del=bat;
-					bat=bat->list.next;		//weird, FIXME
+					bat_to_be_del=bat;		//to be deleted
+					bat=(FAST_BAT *)(*bat->list.pprev);
+					//bat=bat->list.next;		//weird, FIXME
 					mutex_lock(&bats_lock);
-					__hlist_del(&bat_to_be_del->list);
+					if((bat_to_be_del==NULL)) {
+						FASTBAT_ERR_MSG(" ERR! null bat_2_be_del!(idx=%d)\n", idx);
+						fastbat_show_list_entry(idx);
+						break;
+					}
+					if(&bat_to_be_del->list==NULL) {
+						FASTBAT_ERR_MSG(" ERR! null bat_2_be_del->list!(idx=%d)\n", idx);
+						fastbat_show_list_entry(idx);
+						break;
+					}
+					hlist_del(&bat_to_be_del->list);
 					mutex_unlock(&bats_lock);
 					kfree(bat_to_be_del);
-				}
+					if(bat == NULL) {
+						FASTBAT_ERR_MSG(" ERR! null bat ptr(idx=%d)!\n", idx);
+						fastbat_show_list_entry(idx);
+						break;
+					}
 				//fastbat_del_list_entry(bat);
+				}
+#endif
 			}
 		}
 	}
+
 	FASTBAT_DBG_RAW_MSG("[F@STBAT] start to purge local ...\n");
 	if(!list_empty(&fastbat_local_head)) {
 		list_for_each_entry(local, &fastbat_local_head, list) {
@@ -1520,8 +1551,9 @@
 				kfree(local_to_be_del);
 			}
 		}
-	} else
+	} else {
 		FASTBAT_DBG_RAW_MSG("[F@STBAT] local list is empty...\n");
+	}
 }
 
 int		fastbat_show_all_bats
